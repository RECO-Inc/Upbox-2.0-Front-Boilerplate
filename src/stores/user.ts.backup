import { ref, computed } from 'vue'
import { defineStore } from 'pinia'
import type { User, UserToken, Authority } from '@/types/auth'

const SAVEKEY = 'AuthKey'

// JWT 토큰 디코딩 함수
function decodeJWT(token: string): any {
  try {
    const base64Url = token.split('.')[1]
    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/')
    const jsonPayload = decodeURIComponent(
      atob(base64)
        .split('')
        .map((c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))
        .join('')
    )
    return JSON.parse(jsonPayload)
  } catch (error) {
    console.error('Failed to decode JWT:', error)
    return null
  }
}

export const useUserStore = defineStore('user', () => {
  // State
  const user = ref<User | null>(null)
  const token = ref<UserToken | null>(null)
  const refreshTokenPromise = ref<Promise<any> | null>(null)

  // Computed
  const userName = computed(() => user.value?.name || '')
  const userId = computed(() => user.value?.userId || '')
  const uuid = computed(() => user.value?.uuid || '')
  const isAuthenticated = computed(() => !!token.value?.accessToken && !!user.value)

  // 토큰 만료 체크
  const isTokenExpired = (tokenString: string): boolean => {
    try {
      const decoded = decodeJWT(tokenString)
      if (!decoded || !decoded.exp) return true

      // exp는 초 단위이므로 1000을 곱해서 밀리초로 변환
      const expTime = decoded.exp * 1000
      const currentTime = Date.now()

      // 만료 30초 전부터 만료로 간주
      return currentTime >= expTime - 30000
    } catch {
      return true
    }
  }

  const isAccessTokenExpired = computed(() => {
    if (!token.value?.accessToken) return true
    return isTokenExpired(token.value.accessToken)
  })

  // Actions

  /**
   * 토큰 저장 (LocalStorage + State)
   */
  function setToken(userToken: UserToken) {
    token.value = userToken
    try {
      window.localStorage.setItem(SAVEKEY, JSON.stringify(userToken))
    } catch (error) {
      console.error('Failed to save token to localStorage:', error)
    }
  }

  /**
   * 토큰 로드 (LocalStorage -> State)
   */
  function loadTokenFromStorage(): UserToken | null {
    try {
      const stored = window.localStorage.getItem(SAVEKEY)
      if (stored) {
        const parsedToken = JSON.parse(stored) as UserToken
        token.value = parsedToken
        return parsedToken
      }
    } catch (error) {
      console.error('Failed to load token from localStorage:', error)
      window.localStorage.removeItem(SAVEKEY)
    }
    return null
  }

  /**
   * 사용자 정보 설정
   */
  function setUser(userData: User) {
    user.value = userData
  }

  /**
   * 로그인
   */
  function login(userData: User, userToken: UserToken) {
    setUser(userData)
    setToken(userToken)
  }

  /**
   * 로그아웃
   */
  function logout() {
    user.value = null
    token.value = null
    refreshTokenPromise.value = null

    try {
      window.localStorage.removeItem(SAVEKEY)
    } catch (error) {
      console.error('Failed to remove token from localStorage:', error)
    }
  }

  /**
   * 토큰 검증
   * - LocalStorage와 State의 토큰을 비교하여 최신 것 사용
   * - 만료된 경우 갱신 시도
   */
  async function validateToken(): Promise<boolean> {
    // 1. LocalStorage에서 토큰 로드
    const storedToken = loadTokenFromStorage()

    if (!storedToken) {
      throw new Error('No token found')
    }

    // 2. Access Token이 만료되었는지 확인
    if (isTokenExpired(storedToken.accessToken)) {
      // 3. Refresh Token으로 갱신 시도
      if (refreshTokenPromise.value) {
        // 이미 갱신 중이면 대기
        await refreshTokenPromise.value
        return true
      }

      // 4. 토큰 갱신
      return await refreshAccessToken()
    }

    return true
  }

  /**
   * Access Token 갱신
   */
  async function refreshAccessToken(): Promise<boolean> {
    if (refreshTokenPromise.value) {
      await refreshTokenPromise.value
      return true
    }

    if (!token.value?.refreshToken) {
      throw new Error('No refresh token available')
    }

    refreshTokenPromise.value = (async () => {
      try {
        // Import dynamically to avoid circular dependency
        const { AuthService } = await import('@/api/auth.service')
        const response = await AuthService.refreshToken(token.value!.refreshToken)

        setToken({
          accessToken: response.accessToken,
          refreshToken: response.refreshToken || token.value!.refreshToken,
          isRemember: token.value!.isRemember,
        })

        return true
      } catch (error) {
        console.error('Token refresh failed:', error)
        logout()
        throw error
      } finally {
        refreshTokenPromise.value = null
      }
    })()

    return await refreshTokenPromise.value
  }

  /**
   * 권한 체크
   */
  function hasAuthority(authority: Authority): boolean {
    return user.value?.authorityList.includes(authority) || false
  }

  /**
   * 여러 권한 중 하나라도 있는지 체크
   */
  function hasAnyAuthority(authorities: Authority[]): boolean {
    return authorities.some(auth => hasAuthority(auth))
  }

  // Initialize: Load token from localStorage on store creation
  loadTokenFromStorage()

  return {
    // State
    user,
    token,

    // Computed
    userName,
    userId,
    uuid,
    isAuthenticated,
    isAccessTokenExpired,

    // Actions
    setToken,
    setUser,
    login,
    logout,
    validateToken,
    refreshAccessToken,
    loadTokenFromStorage,
    hasAuthority,
    hasAnyAuthority,
  }
})
